## 函数

> 函数的概念

```js
可以封装一段特定功能的代码，通过函数名调用，实现对该代码重复使用
```

> 创建函数的方式

```js
1. 函数声明
function 函数名(){   // 函数体}
2. 函数表达式
var fn = function(){  // 函数体}
```

> 函数执行

```js
函数名()
```

> 函数参数

- 形参

  ```js
  在函数创建时候，小括号中定义的变量
  语法:
  function 函数名(形参一，形参二，形参三,...){}
  ```

- 实参

  ```js
  函数调用时候，小括号中传入的实际数据
  语法：
    函数名(实际参数，数据,数据,数据...);   //实参，就是实际的数据
  ```


  ☞  注意: 形参与实参的数量是可以不相等的
    funtion getSum(a,b,c){}
     // 调用
     getSum(1,2)
     
     解释: 在调用getSum函数，传递实参给形参是一一对应的关系，c没有对应的实参，结果就是 `undefined`

  ```

> 函数的返回值

​```js
函数执行完后，可以把执行的结果 通过 `return`  语法 返回给 调用者

☞ 注意: 1.如果函数没有显示的使用 return语句 ，那么函数有默认的返回值： `undefined`
    2. 如果函数中写了return语句，后面没有写任何其他内容，那么函数的返回值依然是  `undefined`
    3. 一个函数只能有一个返回值
    4.return 代码执行完成后，后面的代码不再执行
  ```

## 函数其他部分

> arguments的使用

```js
如果函数参数不确定，可以定义函数的时候不写参数，通过arguments获取

 ☞ 注意: 1.arguments是一个伪数组，不能使用数组的一系列方法,比方说push,pop等
         2.可以将伪数组转换成数组 ,通过Array.from(伪数组)
         
  伪数组知识的普及: 伪数组是由键值对组成的，并且有length属性的对象
     1. 伪数组是一个对象
     2、这个对象必须要有length属性，且必须是number类型
     例如: var obj1 = {0:"888",1:6,length:2}
```

> 自调用函数

```js
1. 自调用函数可以是命名函数也可以是匿名函数
2. 自调用函数也可以传递参数
2. 自调用函数是立即执行
例如:
(function(){})()或者是(function fn(){})()都是正确的

```

## 作用域

> 作用域分类

```js
1.全局作用域（全局变量）
2.局部作用域（局部变量）:只能在函数内部使用，在函数外部访问就报错
    1)在函数内部用`var`声明的变量
    2)函数得形参也是局部变量
   
   
```

> 作用域链

```js
当访问一个变量时，会先从本作用域中去找这个变量，若找不到则向上一级作用域中去找，依次类推，就形成了一个作用域链。
```

## 预解析

> 预解析规则

```js
1. 变量只提升声明，把变量声明提升到当前作用域的最上面，不提升赋值
2. 函数声明是整体进行提升，函数表达式只提升变量名，不提升赋值，函数调用不提升
3. 同名函数和变量，函数优先于变量   // var a = 10;; function a(){}
4. 如果变量前面没有`var`,这个变量就是`隐式全局变量`

 ☞ 注意：1.在函数内部用var声明的变量，只在函数内部起作用
         2. 函数的形参，相当于在函数内部用var声明一个变量，函数名就是参数名
         3. 函数调用的时候，函数内部才进行预解析，不调用，不进行预解析
```

